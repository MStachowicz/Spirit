#pragma once

#include "Geometry/Ray.hpp"

#include "glm/gtx/quaternion.hpp"
#include "glm/mat4x4.hpp"

#include <filesystem>
#include <functional>
#include <random>
#include <sstream>
#include <string>
#include <vector>

namespace Geometry
{
	class Ray;
}
namespace Utility
{
	constexpr float EPSILON = 1.0E-6F;

	// Compare two floating-point values and return true if they are similar.
	// @param p_a: The first value to compare.
	// @param p_b: The second value to compare.
	// @param p_epsilon: The maximum difference between the two values for them to be considered similar.
	bool equal_floats(const float p_a, const float p_b, const float p_epsilon = EPSILON);

	// Produces a random floating-point value in the interval min to max
	// Satisfies all requirements of RandomNumberDistribution (https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution)
	template<class T>
	static T get_random_number(const T& p_min, const T& p_max)
	{
		if constexpr (std::is_integral<T>::value)
		{
			std::random_device rd;  // Will be used to obtain a seed for the random number engine
			std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
			std::uniform_int_distribution<T> dis(p_min, p_max);
			return dis(gen);
		}
		else if constexpr (std::is_floating_point<T>::value)
		{
			std::random_device rd;  // Will be used to obtain a seed for the random number engine
			std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
			std::uniform_real_distribution<T> dis(p_min, p_max);
			return dis(gen);
		}
		else
			[]<bool flag = false>() { static_assert(flag, "Unsupported random type"); }(); // #CPP23 P2593R0 swap for static_assert(false)
	}
	// Produces a random value for T within the min and max data range of type T.
	template<class T>
	static T get_random_number()
	{
		return get_random_number(std::numeric_limits<T>::min(), std::numeric_limits<T>::max());
	}

	// Produces random floating-point values in the interval min to max
	// Satisfies all requirements of RandomNumberDistribution (https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution)
	template<class T, size_t Size>
	static void fill_random_numbers(const T& p_min, const T& p_max, std::array<T, Size>& p_array)
	{
		// Use std::uniform_real_distribution to transform the random unsigned int generated by std::mt19937 into a type in [p_min, p_max).
		// Each call to dis(gen) generates a new random.

		std::random_device rd;  // Will be used to obtain a seed for the random number engine
		std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
		std::uniform_real_distribution<T> dis(p_min, p_max);

		for (size_t i = 0; i < p_array.size(); i++)
			p_array[i] = dis(gen);
	}
	// Produces random floating-point values in the interval min to max
	// Satisfies all requirements of RandomNumberDistribution (https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution)
	template<class T>
	static std::vector<T> get_random_numbers(const T& p_min, const T& p_max, const size_t& count)
	{
		// Use std::uniform_real_distribution to transform the random unsigned int generated by std::mt19937 into a type in [p_min, p_max).
		// Each call to dis(gen) generates a new random.

		std::random_device rd;  // Will be used to obtain a seed for the random number engine
		std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
		std::uniform_real_distribution<T> dis(p_min, p_max);

		std::vector<T> vec;
		vec.reserve(count);

		for (size_t i = 0; i < count; i++)
			vec.emplace_back(dis(gen));

		return vec;
	}

	template <typename T>
	static T next_power_of_2(const T& p_value)
	{
		static_assert(std::is_integral<T>::value, "next_power_of_2 only works with integral types");
		ASSERT_THROW(p_value > 0, "next_power_of_2 only works with positive values");

		T power = 1;
		while (power < p_value)
			power <<= 1;
		return power;
	}

	inline void trim_trailing_zeros(std::string& str)
	{
		// Find the position of the decimal point
		size_t decimal_pos = str.find('.');

		// If there's no decimal point, nothing to trim
		if (decimal_pos == std::string::npos)
			return;

		// Start from the end of the string and move backwards
		size_t end_pos = str.size() - 1;
		while (end_pos > decimal_pos && str[end_pos] == '0')
			--end_pos;

		// If we stopped at the decimal point, remove it as well
		if (end_pos == decimal_pos)
			--end_pos;

		// Resize the string to remove trailing zeros
		str.resize(end_pos + 1);
	}

	//@param value The number to format.
	//@param decimal_places The number of decimal places to display.
	//@returns A string representation of the number with a metric prefix.
	template <typename T>
	std::string format_number(T value, uint8_t decimal_places = 3)
	{
		const std::pair<double, const char*> metric_prefixes[] = {
		    {1'000'000'000'000.0, "T"}, // Tera
		    {1'000'000'000.0, "G"},     // Giga
		    {1'000'000.0, "M"},         // Mega
		    {1'000.0, "k"},             // Kilo
		    {1.0, ""},                  // No prefix for values between 1 and 999
		    {0.001, "m"},               // Milli
		    {0.000001, "Âµ"},            // Micro
		    {0.000000001, "n"}          // Nano
		};

		// Iterate through the metric prefixes to find the appropriate scale
		for (const auto& prefix : metric_prefixes)
		{
			if (value >= prefix.first || value <= -prefix.first)
			{
				double scaled_value = static_cast<double>(value) / prefix.first;

				// Create a string stream to format the number
				std::ostringstream out;
				out << std::fixed << std::setprecision(decimal_places) << scaled_value << prefix.second;
				auto result = out.str();
				trim_trailing_zeros(result);
				return result;
			}
		}

		// If the value is extremely small (even smaller than nano)
		std::ostringstream out;
		out << std::fixed << std::setprecision(decimal_places) << static_cast<double>(value);
		auto result = out.str();
		trim_trailing_zeros(result);
		return result;
	}
	// Format the number diving by 1024 for bytes
	//@param value The number to format.
	//@param decimal_places The number of decimal places to display.
	//@returns A string representation of the number with a metric prefix.
	template <typename T>
	inline std::string format_number_bytes(T value, uint8_t decimal_places = 3)
	{
		const std::pair<double, const char*> metric_prefixes[] = {
		    {1'099'511'627'776.0, "TB"}, // Tebi
		    {1'073'741'824.0, "GB"},     // Gibi
		    {1'048'576.0, "MB"},         // Mebi
		    {1'024.0, "KB"},             // Kibi
		    {1.0, "B"}                    // Bytes
		};

		// Iterate through the metric prefixes to find the appropriate scale
		for (const auto& prefix : metric_prefixes)
		{
			if (value >= prefix.first)
			{
				double scaled_value = static_cast<double>(value) / prefix.first;

				// Create a string stream to format the number
				std::ostringstream out;
				out << std::fixed << std::setprecision(decimal_places) << scaled_value;
				auto result = out.str();
				trim_trailing_zeros(result);
				return result + prefix.second;
			}
		}

		// If the value is less than 1 byte
		std::ostringstream out;
		out << std::fixed << std::setprecision(decimal_places) << static_cast<double>(value);
		auto result = out.str();
		trim_trailing_zeros(result);
		return result + 'B';
	}
	// @param value The number to format with thousands separators.
	// @return A string representation of the number with the appropriate thousands separator depending on locale.
	template <typename T>
	std::string number_with_seperator(T value)
	{
		std::ostringstream out;
		out.imbue(std::locale("")); // Use the current global locale for thousands separator
		out << std::fixed << value;
		return out.str();
	}

	// Construct a model matrix from position, rotation and scale
	glm::mat4 make_model_matrix(const glm::vec3& p_position, const glm::vec3& p_rotation, const glm::vec3& p_scale);
	// Converts a quaternion rotation into XYZ (Roll-Pitch-Yaw) Euler angles in radians.
	glm::vec3 to_roll_pitch_yaw(const glm::quat p_orientation);
	// Converts Roll-Pitch-Yaw into a quaternion rotation. Roll, pitch and yaw are expected in radians.
	glm::quat to_quaternion(const float& p_roll, const float& p_pitch, const float& p_yaw);
	// Converts XYZ (Roll-Pitch-Yaw) into a quaternion rotation. Roll, pitch and yaw are expected in radians.
	inline glm::quat to_quaternion(const glm::vec3& p_roll_pitch_yaw) { return to_quaternion(p_roll_pitch_yaw.x, p_roll_pitch_yaw.y, p_roll_pitch_yaw.z); }
	//@Param p_start: The normalised starting direction vector.
	//@Param p_destination: The normalised destination direction vector.
	//@Return: The quaternion rotation to get from p_start to p_destination.
	glm::quat get_rotation(const glm::vec3& p_start, const glm::vec3& p_destination);
	// Returns a Ray with a starting point at p_view_position
	Geometry::Ray get_cursor_ray(const glm::vec2& p_cursor_pos, const glm::ivec2& p_window_size, const glm::vec3& p_view_position, const glm::mat4& p_projection, const glm::mat4& p_view);
}