#pragma once

#include "Geometry/Ray.hpp"

#include "glm/gtx/quaternion.hpp"
#include "glm/mat4x4.hpp"

#include <filesystem>
#include <functional>
#include <random>
#include <string>

namespace Geometry
{
	class Ray;
}
namespace Utility
{
	constexpr float EPSILON = 1.0E-6F;

	// Compare two floating-point values and return true if they are similar.
	// @param p_a: The first value to compare.
	// @param p_b: The second value to compare.
	// @param p_epsilon: The maximum difference between the two values for them to be considered similar.
	bool equal_floats(const float p_a, const float p_b, const float p_epsilon = EPSILON);

	// Produces a random floating-point value in the interval min to max
	// Satisfies all requirements of RandomNumberDistribution (https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution)
	template<class T>
	static T get_random_number(const T& p_min, const T& p_max)
	{
		// Use std::uniform_real_distribution to transform the random unsigned int generated by std::mt19937 into a type in [p_min, p_max).
		// Each call to dis(gen) generates a new random.

		std::random_device rd;  // Will be used to obtain a seed for the random number engine
		std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
		std::uniform_real_distribution<T> dis(p_min, p_max);
		return dis(gen);
	}

	// Produces random floating-point values in the interval min to max
	// Satisfies all requirements of RandomNumberDistribution (https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution)
	template<class T, size_t Size>
	static void fill_random_numbers(const T& p_min, const T& p_max, std::array<T, Size>& p_array)
	{
		// Use std::uniform_real_distribution to transform the random unsigned int generated by std::mt19937 into a type in [p_min, p_max).
		// Each call to dis(gen) generates a new random.

		std::random_device rd;  // Will be used to obtain a seed for the random number engine
		std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
		std::uniform_real_distribution<T> dis(p_min, p_max);

		for (size_t i = 0; i < p_array.size(); i++)
			p_array[i] = dis(gen);
	}
	// Produces random floating-point values in the interval min to max
	// Satisfies all requirements of RandomNumberDistribution (https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution)
	template<class T>
	static std::vector<T> get_random_numbers(const T& p_min, const T& p_max, const size_t& count)
	{
		// Use std::uniform_real_distribution to transform the random unsigned int generated by std::mt19937 into a type in [p_min, p_max).
		// Each call to dis(gen) generates a new random.

		std::random_device rd;  // Will be used to obtain a seed for the random number engine
		std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
		std::uniform_real_distribution<T> dis(p_min, p_max);

		std::vector<T> vec;
		vec.reserve(count);

		for (size_t i = 0; i < count; i++)
			vec.emplace_back(dis(gen));

		return vec;
	}

	template <typename T>
	static T next_power_of_2(const T& p_value)
	{
		static_assert(std::is_integral<T>::value, "next_power_of_2 only works with integral types");
		ASSERT_THROW(p_value > 0, "next_power_of_2 only works with positive values");

		T power = 1;
		while (power < p_value)
			power <<= 1;
		return power;
	}

	// Construct a model matrix from position, rotation and scale
	glm::mat4 make_model_matrix(const glm::vec3& p_position, const glm::vec3& p_rotation, const glm::vec3& p_scale);
	// Converts a quaternion rotation into XYZ (Roll-Pitch-Yaw) Euler angles in radians.
	glm::vec3 to_roll_pitch_yaw(const glm::quat p_orientation);
	// Converts Roll-Pitch-Yaw into a quaternion rotation. Roll, pitch and yaw are expected in radians.
	glm::quat to_quaternion(const float& p_roll, const float& p_pitch, const float& p_yaw);
	// Converts XYZ (Roll-Pitch-Yaw) into a quaternion rotation. Roll, pitch and yaw are expected in radians.
	inline glm::quat to_quaternion(const glm::vec3& p_roll_pitch_yaw) { return to_quaternion(p_roll_pitch_yaw.x, p_roll_pitch_yaw.y, p_roll_pitch_yaw.z); }
	//@Param p_start: The normalised starting direction vector.
	//@Param p_destination: The normalised destination direction vector.
	//@Return: The quaternion rotation to get from p_start to p_destination.
	glm::quat get_rotation(const glm::vec3& p_start, const glm::vec3& p_destination);
	// Returns a Ray with a starting point at p_view_position
	Geometry::Ray get_cursor_ray(const glm::vec2& p_cursor_pos, const glm::ivec2& p_window_size, const glm::vec3& p_view_position, const glm::mat4& p_projection, const glm::mat4& p_view);
}