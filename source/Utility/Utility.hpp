#pragma once

#include <functional>
#include <filesystem>
#include <string>
#include <random>

#include "glm/mat4x4.hpp"
#include "glm/gtx/quaternion.hpp"

namespace Utility
{
    template <typename T>
    static constexpr auto toIndex(const T& pEnum) noexcept // Returns the underlying type. Used to convert enum types to indexes into arrays
    {
        return static_cast<std::underlying_type_t<T>>(pEnum);
    }

    // Produces a random floating-point value in the interval min to max
    // Satisfies all requirements of RandomNumberDistribution (https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution)
    template<class T>
    static T getRandom(const T& pMin, const T& pMax)
    {
        // Use std::uniform_real_distribution to transform the random unsigned int generated by std::mt19937 into a type in [pMin, pMax).
        // Each call to dis(gen) generates a new random.

        std::random_device rd;  // Will be used to obtain a seed for the random number engine
        std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
        std::uniform_real_distribution<T> dis(pMin, pMax);
        return dis(gen);
    }

    // Produces random floating-point values in the interval min to max
    // Satisfies all requirements of RandomNumberDistribution (https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution)
    template<class T, size_t Size>
    static void fillRandomNumbers(const T& pMin, const T& pMax, std::array<T, Size>& pArray)
    {
        // Use std::uniform_real_distribution to transform the random unsigned int generated by std::mt19937 into a type in [pMin, pMax).
        // Each call to dis(gen) generates a new random.

        std::random_device rd;  // Will be used to obtain a seed for the random number engine
        std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
        std::uniform_real_distribution<T> dis(pMin, pMax);

        for (size_t i = 0; i < pArray.size(); i++)
            pArray[i] = dis(gen);
    }

    glm::mat4 GetModelMatrix(const glm::vec3& pPosition, const glm::vec3& pRotation, const glm::vec3& pScale);

    // Converts a quaternion rotation into XYZ (Roll-Pitch-Yaw) Euler angles in radians.
    glm::vec3 toRollPitchYaw(const glm::quat pOrientation);
    // Converts Roll-Pitch-Yaw into a quaternion rotation. Roll, pitch and yaw are expected in radians.
    glm::quat toQuaternion(const float& pRoll, const float& pPitch, const float& pYaw);
    // Converts XYZ (Roll-Pitch-Yaw) into a quaternion rotation. Roll, pitch and yaw are expected in radians.
    inline glm::quat toQuaternion(const glm::vec3& pRollPitchYaw) { return toQuaternion(pRollPitchYaw.x, pRollPitchYaw.y, pRollPitchYaw.z); }
    // Returns the quaternon rotation to get from pStart to pDestination direction vectors.
    glm::quat getRotation(const glm::vec3& pStart, const glm::vec3& pDestination);
}