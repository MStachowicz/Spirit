#pragma once

#include "glm/gtx/quaternion.hpp"
#include "glm/mat4x4.hpp"

// GEOMETRY
#include "Ray.hpp"

#include <filesystem>
#include <functional>
#include <random>
#include <string>

namespace Geometry
{
    class Ray;
}

namespace Utility
{
    template <typename T>
    static constexpr auto toIndex(const T& pEnum) noexcept // Returns the underlying type. Used to convert enum types to indexes into arrays
    {
        return static_cast<std::underlying_type_t<T>>(pEnum);
    }

    // Produces a random floating-point value in the interval min to max
    // Satisfies all requirements of RandomNumberDistribution (https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution)
    template<class T>
    static T getRandom(const T& pMin, const T& pMax)
    {
        // Use std::uniform_real_distribution to transform the random unsigned int generated by std::mt19937 into a type in [pMin, pMax).
        // Each call to dis(gen) generates a new random.

        std::random_device rd;  // Will be used to obtain a seed for the random number engine
        std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
        std::uniform_real_distribution<T> dis(pMin, pMax);
        return dis(gen);
    }

    // Produces random floating-point values in the interval min to max
    // Satisfies all requirements of RandomNumberDistribution (https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution)
    template<class T, size_t Size>
    static void fillRandomNumbers(const T& pMin, const T& pMax, std::array<T, Size>& pArray)
    {
        // Use std::uniform_real_distribution to transform the random unsigned int generated by std::mt19937 into a type in [pMin, pMax).
        // Each call to dis(gen) generates a new random.

        std::random_device rd;  // Will be used to obtain a seed for the random number engine
        std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
        std::uniform_real_distribution<T> dis(pMin, pMax);

        for (size_t i = 0; i < pArray.size(); i++)
            pArray[i] = dis(gen);
    }
    // Produces random floating-point values in the interval min to max
    // Satisfies all requirements of RandomNumberDistribution (https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution)
    template<class T>
    static std::vector<T> get_random(const T& pMin, const T& pMax, const size_t& count)
    {
        // Use std::uniform_real_distribution to transform the random unsigned int generated by std::mt19937 into a type in [pMin, pMax).
        // Each call to dis(gen) generates a new random.

        std::random_device rd;  // Will be used to obtain a seed for the random number engine
        std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
        std::uniform_real_distribution<T> dis(pMin, pMax);

        std::vector<T> vec;
        vec.reserve(count);

        for (size_t i = 0; i < count; i++)
            vec.emplace_back(dis(gen));

        return vec;
    }

    glm::mat4 GetModelMatrix(const glm::vec3& pPosition, const glm::vec3& pRotation, const glm::vec3& pScale);

    // Converts a quaternion rotation into XYZ (Roll-Pitch-Yaw) Euler angles in radians.
    glm::vec3 toRollPitchYaw(const glm::quat pOrientation);
    // Converts Roll-Pitch-Yaw into a quaternion rotation. Roll, pitch and yaw are expected in radians.
    glm::quat toQuaternion(const float& pRoll, const float& pPitch, const float& pYaw);
    // Converts XYZ (Roll-Pitch-Yaw) into a quaternion rotation. Roll, pitch and yaw are expected in radians.
    inline glm::quat toQuaternion(const glm::vec3& pRollPitchYaw) { return toQuaternion(pRollPitchYaw.x, pRollPitchYaw.y, pRollPitchYaw.z); }
	//@Param p_start: The normalised starting direction vector.
	//@Param p_destination: The normalised destination direction vector.
	//@Return: The quaternion rotation to get from p_start to p_destination.
    glm::quat getRotation(const glm::vec3& p_start, const glm::vec3& p_destination);

    // Returns the world space direction the cursor is pointing by reversing the projection and view matrices.
    glm::vec3 get_cursor_direction(const glm::vec2& p_cursor_pos, const glm::ivec2& p_window_size, const glm::mat4& p_projection, const glm::mat4& p_view);
    // Returns a Ray with a starting point at p_view_position
    Geometry::Ray get_cursor_ray(const glm::vec2& p_cursor_pos, const glm::ivec2& p_window_size, const glm::vec3& p_view_position, const glm::mat4& p_projection, const glm::mat4& p_view);
}