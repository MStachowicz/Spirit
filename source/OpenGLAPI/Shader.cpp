#include "Shader.hpp"

#include "FileSystem.hpp"
#include "Logger.hpp"

#include "glad/gl.h"

#include "glm/mat4x4.hpp" // mat4, dmat4
#include "glm/gtc/type_ptr.hpp" //  glm::value_ptr

 Shader::Shader(const std::string &pName)
	: mName(pName)
	, mSourcePath(File::GLSLShaderDirectory)
{
	load();
}

void Shader::load()
{
	const std::string vertexShaderPath 		= mSourcePath + mName + ".vert";
	const std::string fragmentShaderPath 	= mSourcePath + mName + ".frag";
	ZEPHYR_ASSERT(File::exists(vertexShaderPath), "Vertex shader does not exist at path {}", vertexShaderPath);
	ZEPHYR_ASSERT(File::exists(fragmentShaderPath), "Fragment shader does not exist at path {}", fragmentShaderPath);

	unsigned int vertexShader;
	{
		vertexShader = glCreateShader(GL_VERTEX_SHADER);
		std::string source = File::readFromFile(vertexShaderPath);
		const char *vertexShaderSource = source.c_str();
		glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
		glCompileShader(vertexShader);
		ZEPHYR_ASSERT(!hasCompileErrors(Type::Vertex, vertexShader), "Failed to compile vertex shader {}", mName + ".vert")
	}

	unsigned int fragmentShader;
	{
		fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
		std::string source = File::readFromFile(fragmentShaderPath);
		const char *fragmentShaderSource = source.c_str();
		glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
		glCompileShader(fragmentShader);
		ZEPHYR_ASSERT(!hasCompileErrors(Type::Fragment, fragmentShader), "Failed to compile fragment shader {}", mName + ".frag")
	}

	{
		mHandle = glCreateProgram();
		glAttachShader(mHandle, vertexShader);
		glAttachShader(mHandle, fragmentShader);
		glLinkProgram(mHandle);
		ZEPHYR_ASSERT(!hasCompileErrors(Type::Program, mHandle), "Failed to link shader {}", mName)
	}

	// Delete the shaders after linking as they're no longer needed
	glDeleteShader(vertexShader);
	glDeleteShader(fragmentShader);
	LOG_INFO("Shader '{}' loaded given ID: {}", mName, mHandle);
}

void Shader::use()
{
	glUseProgram(mHandle);
	shaderInUse = this;
}

int Shader::getAttributeLocation(const Attribute& pAttribute) const
{
	const GLint location = glGetAttribLocation(mHandle, getAttributeName(pAttribute).c_str());
	ZEPHYR_ASSERT(location != -1, "Failed to find the location of {} in shader {}.", pName, mName);
	return static_cast<int>(location);
}

int Shader::getUniformLocation(const std::string &pName)
{
	int location = glGetUniformLocation(mHandle, pName.c_str());
	// TODO: assert iterate over the loaded shaders to see if the shader ID exists
	ZEPHYR_ASSERT(location != GL_INVALID_VALUE, "ShaderID is not a value generated by OpenGL");
	ZEPHYR_ASSERT(location != GL_INVALID_OPERATION, "ShaderID is not a program object or has not been successfully linked");
	ZEPHYR_ASSERT(location != -1, "UniformName does not correspond to an active uniform variable in ShaderID or UniformName starts with the reserved prefix 'gl_'");

	return location;
}

bool Shader::checkForUseErrors(const Shader& pCalledFrom)
{
	if (!shaderInUse)
	{
		LOG_ERROR("No shader has been set to current in OpenGL state, call Shader::Use() before trying to set a uniform.");
		return false;
	}
	if (shaderInUse != &pCalledFrom)
	{
		LOG_ERROR("Trying to set a uniform on a shader not current in OpenGL state, call Shader::Use() before trying to set a uniform.");
		return false;
	}
	else
		return true;
}

void Shader::setUniform(const std::string &pName, const bool &pValue)
{
	ZEPHYR_ASSERT(checkForUseErrors(*this), "Trying to set uniforms on a shader ({}) without calling use() before.", mName);
	glUniform1i(getUniformLocation(pName), (int)pValue); // Setting a boolean is treated as integer for gl shaders
}

void Shader::setUniform(const std::string &pName, const int &pValue)
{
	ZEPHYR_ASSERT(checkForUseErrors(*this), "Trying to set uniforms on a shader ({}) without calling use() before.", mName);
	glUniform1i(getUniformLocation(pName), (GLint)pValue);
}

void Shader::setUniform(const std::string &pName, const glm::mat4 &pValue)
{
	ZEPHYR_ASSERT(checkForUseErrors(*this), "Trying to set uniforms on a shader ({}) without calling use() before.", mName);
	glUniformMatrix4fv(getUniformLocation(pName), 1, GL_FALSE, glm::value_ptr(pValue));
}

std::string Shader::getAttributeName(const Attribute& pAttribute)
{
	if (pAttribute == Attribute::Position3D)
		return "VertexPosition";
	else if (pAttribute == Attribute::Normal3D)
		return "VertexNormal";
	else if (pAttribute == Attribute::ColourRGB)
		return  "VertexColour";
	else if (pAttribute == Attribute::TextureCoordinate2D)
		return "VertexTexCoord";
	else
		ZEPHYR_ASSERT(false, "Could not convert Shader::Attribute '{}' to an std::string", pAttribute);
}

bool Shader::hasCompileErrors(const Type& pType, const unsigned int pID)
{
	int success;
	if (pType == Type::Program)
	{
		glGetProgramiv(pID, GL_LINK_STATUS, &success);
		if (!success)
		{
			char infoLog[1024];
			glGetProgramInfoLog(pID, 1024, NULL, infoLog);
			LOG_ERROR("Program linking failed with info: {}", infoLog);
			return true;
		}
	}
	else
	{
		glGetShaderiv(pID, GL_COMPILE_STATUS, &success);
		if (!success)
		{
			char infoLog[1024];
			glGetShaderInfoLog(pID, 1024, NULL, infoLog);
			LOG_ERROR("Shader compilation failed with info: {}", infoLog);
			return true;
		}
	}

	return false;
}